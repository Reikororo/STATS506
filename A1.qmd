---
title: "STATS506A1 Leshan Song"
format: 
    html:
         embed-resources: true
   
editor: visual
---

```{r}
#Import the data into a data.frame in R 
df <- read.table('/Users/songleshan/Desktop/stats506/wine/wine.data', sep = ",")
#Use the information in the “wine.names” file to give appropriate column names.
names(df)<-c('Class', 'Alcohol', 'Malic acid', 'Ash',
             'Alcalinity of ash', 'Magnesium', 'Total phenols',
             'Flavanoids', 'Nonflavanoid phenols', 'Proanthocyanins',
             'Color intensity', 'Hue',
             'OD280/OD315 of diluted wines', 'Proline')          

```

```{r}
table(df$Class)#the number of wines within each class is correct as reported in “wine.names”.
df$Class[which.max(df$Alcohol)]#The wine with the highest alcohol content belongs to 1st class
df$Class[which.min(df$Alcohol)]#The wine with the lowest alcohol content belongs to 2nd class
```

```{r}
sum(df$Magnesium > 114)#26 of these wines have higher levels of magnesium than that.
sum((df$Magnesium > 114) & (df$Class == 1))#15 of class1 wines have higher levels of magnesium than that.
sum((df$Magnesium > 114) & (df$Class == 2))#6 of class2 wines have higher levels of magnesium than that.
sum((df$Magnesium > 114) & (df$Class == 3))#5 of class3 wines have higher levels of magnesium than that.
```

```{r}
#Create a table identifying the average value of each variable, providing one row for the overall average, and one row per class with class averages. 
meanall <- sapply(df, mean)
meanclass1 <- sapply(df[df$Class == 1,], mean)
meanclass2 <- sapply(df[df$Class == 2,], mean)
meanclass3 <- sapply(df[df$Class == 3,], mean)
mat <- rbind(meanall, meanclass1, meanclass2, meanclass3)
df2 <- data.frame(mat[, (-1)])
df2
```

```{r}
#welch t-test for class1 and class2
t.test(df[df$Class == 1, 4], df[df$Class == 2, 4])
#calculate manually
#difference of mean
d <- mean(df[df$Class == 1, 4]) - mean(df[df$Class == 2, 4])
s1 <- sqrt(var(df[df$Class == 1,4])/59)
s2 <- sqrt(var(df[df$Class == 2,4])/71)
#calculate pooled sd
s <- sqrt(s1^2+s2^2)
#calculate adjusted degrees of freedom
dof <- (s1^2/59+s2^2/71)^2/(s1^4/(59*59*58)+s2^4/(71*71*70))
#calculate t
t <- d/sqrt(s1^2+s2^2)
dof
t
#two-tail p value
2*(1-pt(t, dof))
#p-value<0.05 We have sufficient evidence to conclude that the level of Ash differs across class1 and class2.
#welch t-test for class1 and class3
t.test(df[df$Class == 1, 4], df[df$Class == 3, 4])
#calculate manually
d <- mean(df[df$Class == 1, 4])-mean(df[df$Class == 3, 4])
s1 <- sqrt(var(df[df$Class == 1,4])/59)
s2 <- sqrt(var(df[df$Class == 3,4])/48)
s <- sqrt(s1^2+s2^2)
dof <- (s1^2/59+s2^2/48)^2/(s1^4/(59*59*58)+s2^4/(48*48*47))
t <- d/sqrt(s1^2+s2^2)
dof
t
2*(1-pt(t, dof))
#p-value>0.05 We don't have sufficient evidence to conclude that the level of Ash differs across class1 and class3.
#welch t-test for class2 and class3
t.test(df[df$Class == 2, 4],df[df$Class == 3, 4])
#calculate manually
d <- mean(df[df$Class == 2,4])-mean(df[df$Class == 3,4])
s1 <- sqrt(var(df[df$Class == 2,4])/71)
s2 <- sqrt(var(df[df$Class == 3,4])/48)
s <- sqrt(s1^2+s2^2)
dof <- (s1^2/71+s2^2/48)^2/(s1^4/(71*71*70)+s2^4/(48*48*47))
t <- d/sqrt(s1^2+s2^2)
dof
t
2*(1-pt(abs(t), dof))
#p-value<0.05 We have sufficient evidence to conclude that the level of Ash differs across class3 and class2.
```

```{r}
isPerfectPower <- function(n, p) {
  r <- n^(1/p)
  if (all.equal(round(r), r) == TRUE) {
    l <- list('isPerfectPower' = TRUE, 'root' = r)
    return(l)
  } else {
    l <- list('isPerfectPower' = FALSE)
    return(l)
  }
}

isPerfectPower(8000, 3)
isPerfectPower(200, 2)

```

```{r}
findRootPower <- function(int) {
  i <- 2
  while (i <= 1001) {
    if (isPerfectPower(int, i)[[1]] == FALSE){
      i <- i+1
      r <- int^(1/i)
    } else break
  }
  if (i >= 1001) {
    return('this int is not the perfect power for power<=1000')
  } else return(paste0(int,'=',r,'^',i))
}

findRootPower(1000)
findRootPower(13060694016)
findRootPower(7776)
findRootPower(170859375)
findRootPower(58247422)
findRootPower(94143178827)
findRootPower(3)
findRootPower(13)
```

***code below is generated by ChatGPT except for a minor modification and some comments***

```{r}
# Function to determine the name of a poker hand
getHandName <- function(suits, ranks) {
  # Count the occurrences of each rank
  rankCounts <- table(ranks)
  
  # Check for a flush
  isFlush <- length(unique(suits)) == 1
  
  # Check for a straight
  isStraight <- all(diff(sort(unique(ranks))) == 1)
  #original version by ChatGPT:isStraight <- diff(sort(unique(ranks))) == 1
  
  # Check for a straight flush
  isStraightFlush <- isFlush && isStraight
  
  # Check for four of a kind
  isFourOfAKind <- any(rankCounts == 4)
  
  # Check for a full house
  isFullHouse <- any(rankCounts == 3) && any(rankCounts == 2)
  
  # Check for a three of a kind
  isThreeOfAKind <- any(rankCounts == 3)
  
  # Check for two pairs
  isTwoPair <- sum(rankCounts == 2) >= 2
  
  # Check for a pair
  isPair <- any(rankCounts == 2)
  
  # Determine the hand name based on the above checks
  if (isStraightFlush) {
    return("Straight Flush")
  } else if (isFourOfAKind) {
    return("Four of a Kind")
  } else if (isFullHouse) {
    return("Full House")
  } else if (isFlush) {
    return("Flush")
  } else if (isStraight) {
    return("Straight")
  } else if (isThreeOfAKind) {
    return("Three of a Kind")
  } else if (isTwoPair) {
    return("Two Pair")
  } else if (isPair) {
    return("Pair")
  } else {
    #doesn't belong to any hand name above
    return("High Card")
  }
}

# Function to simulate dealing a round of cards in poker
dealPokerRound <- function(numPlayers) {
  # Create a deck of cards
  #4 different suits, each appears for 13 times
  suits <- rep(c("Spades", "Hearts", "Diamonds", "Clubs"), times = 13)
  #13 different suits, each appears for 4 times
  ranks <- rep(1:13, times = 4)
  # Shuffle the deck by sampling index 1 to 52 without replacement
  deck <- sample(1:52)
  
  # Deal cards to each player
  hands <- vector("list", numPlayers)
  for (i in 1:numPlayers) {
    #e.g the resampled deck is (51,4,2,7,8,21,33,20,25,1.......)
    #player 1 gets the first five index(51,4,2,7,8),
    #player 2 gets the second five index(21,33,20,25,1), etc
    start <- (i - 1) * 5 + 1
    end <- start + 4
    hand <- deck[start:end]
    #then the players get the suits and ranks from the vectors of ranks and suits 
    #subset by the indexes
    #e.g the vector of ranks is (1,1,1,1,2,2,2,2,3,3,3,3,....)
    #the player with the hand of index(1,3,4,5,10) gets the ranks of(1,1,1,2,3)
    suitsHand <- suits[hand]
    ranksHand <- ranks[hand]
    #get the handname of this combination of suits and ranks
    handName <- getHandName(suitsHand, ranksHand)
    #create the result dataframe
    hands[[i]] <- data.frame(Suit = suitsHand, Rank = ranksHand, HandName = handName)
  }
  
  # Display the hands
  for (i in 1:numPlayers) {
    #print ith Player player's hand of card
    #e.g Player 1 Hand:
    #Straight
    #
    cat("Player", i, "Hand:\n")
    print(hands[[i]])
    cat("\n")
  }
}
```

```{r}
# Example of getHandName
suits <- c("Spades", "Hearts", "Diamonds", "Clubs", "Spades")
ranks <- c(2, 3, 4, 5, 6)
#should be Straight
handName <- getHandName(suits, ranks)
print(handName)

suits <- c("Spades", "Spades", "Spades", "Spades", "Spades")
ranks <- c(2, 3, 4, 5, 6)
#should be Straight Flush
handName <- getHandName(suits, ranks)
print(handName)

suits <- c("Spades", "Hearts", "Diamonds", "Clubs", "Spades")
ranks <- c(2, 2, 2, 3, 6)
#should be Three of A kind
handName <- getHandName(suits, ranks)
print(handName)

suits <- c("Spades", "Hearts", "Diamonds", "Clubs", "Spades")
ranks <- c(3, 3, 3, 5, 5)
#should be full house
handName <- getHandName(suits, ranks)
print(handName)

suits <- c("Spades", "Hearts", "Diamonds", "Clubs", "Spades")
ranks <- c(3, 7, 4, 11, 12)
#should be High Card
handName <- getHandName(suits, ranks)
print(handName)


suits <- c("Spades", "Hearts", "Diamonds", "Clubs", "Spades")
ranks <- c(2, 2, 2, 2, 6)
#should be Four of A kind
handName <- getHandName(suits, ranks)
print(handName)

suits <- c("Spades", "Hearts", "Diamonds", "Clubs", "Spades")
ranks <- c(2, 2, 4, 4, 8)
#should be Two pair
handName <- getHandName(suits, ranks)
print(handName)


suits <- c("Spades", "Hearts", "Diamonds", "Clubs", "Spades")
ranks <- c(2, 2, 4, 5, 8)
#should be Two pair
handName <- getHandName(suits, ranks)
print(handName)


#Examples of dealPokerRound
set.seed(1)
t1 <- dealPokerRound(4)
set.seed(2)
t2 <- dealPokerRound(4)
set.seed(3)
t3 <- dealPokerRound(4)
set.seed(4)
t4 <- dealPokerRound(4)
t5 <- dealPokerRound(10)

```

**See if the code runs without modification in R. If so, demonstrate it with a range of inputs. If not, fix it and explain what you fixed. (If you identify that the code is massively broken, try re-generating the response.) At this point we only care if the code runs without errors for a variety on inputs; we'll make sure it's correct below.**

The code runs with only a small error that isStraight \<- diff(sort(unique(ranks))) == 1 there shows the warning:

*if (isStraight) { :*

*the condition has length \> 1 and only the first element will be used*

and the hand like (1,2,3,6,8)was considered as straight falsely

I modified it as isStraight\<-all(diff(sort(unique(ranks)))== 1)

**Are the inputs and outputs as described above?**

Yes, for the first function,the name of hand is output after inputting the vector of suits and ranks. For the second function, the hand of cards are simulated after inputting number of players

**Are the hands valid (e.g. real cards, no duplicates, right number)?**

The hands are valid at least for the outputs of above 5 trials

**Are the names of the hands correct?**

The names of hands are correct except that Royal flush is not defined-

**Does it ensure no duplicates in cards across hands? What happens if you ask for more than 10 hands to be dealt (as there are only 52 cards in a standard deck)?**

Yes, it ensures no duplicate in cards across hands as the default setting for sample() is replace=FALSE

But if there are more than 10 hands, the suit and rank of extra cards will be displayed as NA, and the hand with all NA will be identified as Straight Flush

```{r}
dealPokerRound(11)
dealPokerRound(12)
```
